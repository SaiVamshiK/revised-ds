Anandi and Jagya were getting married again when they have achieved proper age.
 Dadi Sa invited Alok Nath to do the kanyadaan and give blessings. Alok Nath has 2 blessings. 
 Each bessing is in the form of a string consisting of lowercase charaters(a-z) only. 
 But he can give only one blessing of K length because some priest told him to do so. 
 Thus he decides to generate a blessing using the other two blessings. While doing this 
 he wants to ensure that happiness brought into their life by his blessing is maximum.
The generated blessing is a common subsequence of length K of the two blessings he has. 
Happiness of the blessing he generates is calculated by the sum of ASCII values of characters in 
the blessing and he wants the happiness to be maximum. If he is not able to generate a common subsequence 
of length K then the happiness is 0 (zero). Alok Nath comes to you and asks you to find the maximum happiness that can be generated by the two blessings he has.

********************************	SEE THIS APPROACH		********************************

#include <bits/stdc++.h>
using namespace std;
int func(string s1,string s2,int n,int m,int k,vector<vector<vector<int>>> &dp)
{
    if(k==0)
    {
        return 0;
    }
    if(n==0||(m==0))
    {
        return INT_MIN;
    }
    if(dp[n][m][k]!=-1)
    {
        return dp[n][m][k];
    }
	if(s1[n-1]==s2[m-1])
    {
        int val1=func(s1,s2,n-1,m-1,k-1,dp);
        int op1;
        if(val1!=INT_MIN)
        {
        	op1=int(s1[n-1])+val1;    
        }else{
            op1=INT_MIN;
        }
        int val2=func(s1,s2,n-1,m,k,dp);
        int val3=func(s1,s2,n,m-1,k,dp);
        int op2;
        if(val2!=INT_MIN&&(val3!=INT_MIN))
        {
        	op2=max(val2,val3);    
        }else if(val2!=INT_MIN)
        {
            op2=val2;
        }else if(val3!=INT_MIN)
        {
            op2=val3;
        }else{
            op2=INT_MIN;
        }
        return dp[n][m][k]=max(op1,op2);
    }else{
        int val1=func(s1,s2,n-1,m,k,dp);
        int val2=func(s1,s2,n,m-1,k,dp);
        int op1;
        if(val1!=INT_MIN&&(val2!=INT_MIN))
        {
            op1=max(val1,val2);
        }else if(val1!=INT_MIN)
        {
            op1=val1;
        }else if(val2!=INT_MIN)
        {
            op1=val2;
        }else{
            op1=INT_MIN;
        }
        return dp[n][m][k]=op1;
    }
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        string s1,s2;
        cin>>s1>>s2;
        int k;
        cin>>k;
        int n=s1.size(),m=s2.size();
        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(m+1,vector<int>(k+1,-1)));
        int ans=func(s1,s2,n,m,k,dp);
        if(ans==INT_MIN)
        {
            cout<<0<<endl;
            continue;
        }
        cout<<ans<<endl;
    }
    return 0;
}



#include <bits/stdc++.h>
using namespace std;
int func(string s1,string s2,int n,int m,int k,vector<vector<vector<int>>> &dp)
{
    if(k==0)
    {
		return 0;
    }
    if(n==0||(m==0))
    {
        return INT_MIN;
    }
    if(dp[n][m][k]!=-1)
    {
        return dp[n][m][k];
    }
	if(s1[n-1]==s2[m-1])
    {
		int op1=func(s1,s2,n-1,m-1,k-1,dp)+int(s1[n-1]);
        int op2=func(s1,s2,n,m-1,k,dp);
        int op3=func(s1,s2,n-1,m,k,dp);
        return dp[n][m][k]=max(op1,max(op2,op3));
    }else{
        int op1=func(s1,s2,n,m-1,k,dp);
        int op2=func(s1,s2,n-1,m,k,dp);
        return dp[n][m][k]=max(op1,op2);
    }
}
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        string s1,s2;
        cin>>s1>>s2;
        int n=s1.size(),m=s2.size();
        int k;
        cin>>k;
        vector<vector<vector<int>>> dp(n+1,vector<vector<int>> (m+1,vector<int> (k+1,-1)));
        int ans=func(s1,s2,n,m,k,dp);
        if(ans<0){
            cout<<0<<endl;
        }else{
            cout<<(ans)<<endl;
        }
    }
    return 0;
}



























